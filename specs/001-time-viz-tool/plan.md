# 實作計畫：一日時間視覺化工具

**分支**: `001-time-viz-tool` | **日期**: 2025-12-27 | **規格**: `specs/001-time-viz-tool/spec.md`

## 摘要

一日時間視覺化工具是一個靜態前端網頁應用，幫助使用者以「時間容量」概念規劃一天的任務。使用者透過建立時間區塊、拖曳到今日容器中，直觀感受時間負荷。採用 HTML5 + CSS3 + Vanilla JavaScript 的組合，使用 localStorage 進行本地資料持久化，可部署到 GitHub Pages。

## 技術背景

**語言版本**: HTML5、CSS3、ECMAScript 2020+  
**主要依賴**: 無外部框架依賴（Vanilla JavaScript）  
**儲存方式**: localStorage（瀏覽器本地儲存）  
**測試**: 無特殊測試框架需求（可使用原生 HTML 測試或簡單單測）  
**目標平台**: 桌面網頁瀏覽器（Chrome、Firefox、Safari、Edge）  
**專案類型**: 單一靜態前端網頁應用  
**效能目標**: 拖曳反應時間 < 100ms、頁面加載時間 < 2s  
**限制條件**: 無後端伺服器依賴、支援離線使用、相容性達 100%  
**規模/範圍**: MVP 階段，支援最多 100 個任務

## 憲法檢查

*門檻: 必須在 Phase 0 研究前通過。在 Phase 1 設計後重新評估。*

**檢查項目**:
- ✅ 專案類型明確（靜態前端網頁應用）
- ✅ 技術棧選擇明確（Vanilla JS + localStorage）
- ✅ 無複雜的架構決策（單一靜態應用）
- ✅ 設計原則清晰（簡單直覺、視覺優先、無壓力）
- ✅ 功能範圍明確（MVP 內容完整定義）

**狀態**: ✅ **通過** - 無關鍵門檻違反

## 專案結構

### 文檔結構（此功能）

```text
specs/001-time-viz-tool/
├── plan.md              # 本文件 - 實作計畫
├── spec.md              # 功能規格
├── research.md          # Phase 0 輸出（可選）
├── data-model.md        # Phase 1 輸出：資料模型
├── contracts/           # Phase 1 輸出：API 契約（如適用）
├── quickstart.md        # Phase 1 輸出：快速開始指南
└── tasks.md             # Phase 2 輸出：任務清單（需 /speckit.tasks 命令）
```

### 源碼結構

```text
docs/time-viz-tool/     # GitHub Pages 部署目錄
├── index.html           # 主頁面（結構 + 初始化腳本）
├── css/
│   ├── styles.css       # 全局樣式
│   ├── components.css   # 元件樣式（容器、區塊、按鈕等）
│   └── layout.css       # 佈局樣式（flex、grid）
├── js/
│   ├── main.js          # 應用程式入口點
│   ├── models/
│   │   ├── Task.js      # 任務資料模型
│   │   ├── TimeBlock.js # 時間區塊模型
│   │   └── Store.js     # localStorage 管理層
│   ├── components/
│   │   ├── TaskInput.js     # 任務輸入元件
│   │   ├── TaskPool.js      # 任務池元件
│   │   ├── DayContainer.js  # 今日容器元件
│   │   ├── TimeBlock.js     # 時間區塊元件
│   │   └── ReferenceLines.js # 參考線元件
│   └── services/
│       ├── DragDrop.js  # 拖曳功能服務
│       └── UI.js        # UI 更新與渲染服務
└── assets/
    └── favicon.ico      # 網站圖示
```

**結構決策**: 採用靜態網頁結構，不使用任何構建工具或模組化系統。所有 JS 文件透過 `<script>` 標籤直接引入，確保可在 GitHub Pages 上直接部署。模組化的 JS 文件便於維護和測試。

## 技術棧選擇與說明

### 核心技術

| 技術 | 選擇 | 原因 |
|------|------|------|
| **前端框架** | 無框架（Vanilla JS） | MVP 無需複雜框架，使用原生 Web API 可減少依賴、降低加載時間 |
| **標記語言** | HTML5 | 提供語義化元素、Drag & Drop API、localStorage 等原生支援 |
| **樣式引擎** | CSS3 | 支援 Flexbox/Grid 佈局、變數、過渡效果，無需預處理器 |
| **動態行為** | ES2020+ | 現代瀏覽器廣泛支援，可使用 async/await、class、模組等特性 |
| **儲存方案** | localStorage | 適合單機應用、自動持久化、無需後端、瀏覽器原生支援 |
| **部署方案** | GitHub Pages | 靜態網站免費託管、自動部署、無伺服器成本 |

### 選擇替代方案分析

**為何不用框架（React/Vue/Angular）？**
- MVP 功能簡單，不需複雜狀態管理
- 減少學習曲線，快速實現
- 降低初始加載體積（無框架運行時開銷）
- 完全控制 DOM，便於精細化拖曳體驗

**為何不用後端伺服器？**
- 規格明確要求「無後端」，只需本地儲存
- localStorage 足夠 MVP 需求（100 個任務 = ~10KB）
- 降低部署複雜度，無需伺服器維護

## 專案佈局與分層設計

### 分層架構

```
┌─────────────────────────────────────┐
│  UI 層 (UI Layer)                    │
│  - HTML 結構 + CSS 樣式              │
│  - 使用者互動回應                     │
└─────────────────┬───────────────────┘
                  │
┌─────────────────▼───────────────────┐
│  元件層 (Component Layer)             │
│  - TaskInput, TaskPool              │
│  - DayContainer, TimeBlock          │
│  - 拖曳邏輯封裝                       │
└─────────────────┬───────────────────┘
                  │
┌─────────────────▼───────────────────┐
│  服務層 (Service Layer)              │
│  - DragDrop 服務                     │
│  - UI 更新服務                        │
└─────────────────┬───────────────────┘
                  │
┌─────────────────▼───────────────────┐
│  資料層 (Data Layer)                 │
│  - Task, TimeBlock 模型              │
│  - Store (localStorage 管理)         │
└─────────────────────────────────────┘
```

## 開發階段拆分

### Phase 1：靜態頁面構建（2-3 天）

**目標**: 建立基礎 UI，實現頁面結構和樣式。

**任務**:
1. **H1.1** 建立 HTML 基礎結構
   - 任務建立區（輸入欄位、時長選擇、新增按鈕）
   - 任務池容器
   - 今日容器（含參考線）
   - 必要的 DOM 元素 ID 和 class

2. **H1.2** 實現 CSS 基礎樣式
   - 容器佈局（Flexbox 主要佈局）
   - 時間區塊樣式（高度與時長對應）
   - 色彩方案和排版
   - 響應式設計（桌面優先）

3. **H1.3** 建立資源文件結構
   - 分離 CSS 文件（styles.css、components.css、layout.css）
   - 建立 js 目錄和模組結構
   - 完成初始 HTML 骨架

**驗收標準**:
- ✅ 頁面在瀏覽器中正確顯示
- ✅ 時間區塊的視覺高度與時長成正比（例：2hr 區塊高度為 1hr 的 2 倍）
- ✅ 容器邊界清晰，無視覺破版

### Phase 2：資料模型與儲存（2-3 天）

**目標**: 實現資料層，支援任務建立和持久化。

**任務**:
1. **D2.1** 定義資料模型
   - `Task` 類：`{ id, name, duration, createdAt }`
   - `TimeBlock` 類：繼承 Task，新增 `position` 和 `status` 屬性
   - 驗證邏輯（任務名稱非空、時長有效）

2. **D2.2** 實現 Store（localStorage 管理）
   - 序列化/反序列化邏輯
   - CRUD 操作封裝
   - 異常處理（儲存容量限制）
   - 資料遷移版本控制

3. **D2.3** 整合初始化邏輯
   - 頁面加載時從 localStorage 恢復資料
   - 首次訪問時初始化空狀態
   - 資料檢驗和修復

**驗收標準**:
- ✅ 新建任務正確儲存到 localStorage
- ✅ 頁面重新加載後資料完整恢復
- ✅ 超過儲存限制時有友善提示

### Phase 3：任務建立功能（2 天）

**目標**: 實現任務輸入和區塊生成。

**任務**:
1. **I3.1** 實現任務輸入元件
   - 監聽輸入欄位和時長選擇
   - 驗證輸入（名稱非空、選擇有效時長）
   - 點擊「新增」按鈕觸發建立

2. **I3.2** 實現任務建立流程
   - 建立 Task 實例並儲存
   - 產生對應的 TimeBlock 視覺呈現
   - 新增到任務池 DOM

3. **I3.3** 實現任務池渲染
   - 將待放置任務顯示為區塊
   - 區塊大小與時長對應
   - 區塊上顯示任務名稱和時長

**驗收標準**:
- ✅ 使用者輸入任務名稱和時長後，點擊「新增」立即出現對應區塊
- ✅ 區塊的視覺大小正確反映時長
- ✅ 可建立至少 10 個任務無誤

### Phase 4：拖曳與互動（3-4 天）

**目標**: 實現拖曳功能和區塊移動邏輯。

**任務**:
1. **I4.1** 實現 HTML5 Drag & Drop API
   - 設定拖曳源（任務池中的區塊）
   - 設定放置區域（今日容器）
   - 拖曳開始、進行中、結束的事件處理

2. **I4.2** 實現區塊堆疊邏輯
   - 區塊進入今日容器時自動堆疊
   - 計算堆疊高度和排列順序
   - 容器溢出時允許視覺上超出邊界

3. **I4.3** 實現反向拖曳
   - 區塊從今日容器拖回任務池
   - 自動更新狀態和視覺呈現
   - 容器中剩餘區塊自動重排

4. **I4.4** 實現刪除功能
   - 每個區塊上添加刪除按鈕
   - 點擊刪除移除區塊（任務池）或移除並隱藏（今日容器）
   - 刪除後自動保存狀態

**驗收標準**:
- ✅ 拖曳區塊進容器時順暢無卡頓，反應時間 < 100ms
- ✅ 區塊正確堆疊，無重疊或遺漏
- ✅ 刪除操作立即生效

### Phase 5：邊界處理與優化（2-3 天）

**目標**: 處理邊界情況，確保產品穩定性。

**任務**:
1. **E5.1** 處理邊界情況
   - 空白任務名稱提示或自動產生預設名稱
   - 超長任務名稱截斷顯示
   - 極端時長（8hr+ ）的正常顯示
   - 快速連續操作的正確處理

2. **E5.2** 效能優化
   - DOM 操作批量化
   - 事件代理（event delegation）減少監聽器數量
   - CSS 優化（減少重排、重繪）

3. **E5.3** 瀏覽器相容性測試
   - Chrome、Firefox、Safari、Edge 的相容性驗證
   - Drag & Drop API 的降級方案（如需）

4. **E5.4** 無障礙優化（可選）
   - 鍵盤導航支援（Tab、Enter）
   - 螢幕閱讀器相容性基礎

**驗收標準**:
- ✅ 支援的所有瀏覽器上正常運作
- ✅ 處理異常輸入無崩潰

### Phase 6：部署與文檔（1-2 天）

**目標**: 準備上線和維護文檔。

**任務**:
1. **P6.1** GitHub Pages 部署
   - 設定 GitHub Pages 源目錄
   - 確保靜態資源正確引入
   - 測試線上訪問

2. **P6.2** 撰寫文檔
   - README.md（功能簡介、使用指南）
   - 開發指南（本地運行、構建流程）
   - 功能列表和已知限制

3. **P6.3** 最終測試
   - MVP 功能完整性測試
   - 使用者可用性測試（內部或早期使用者）
   - 效能和相容性最終驗證

**驗收標準**:
- ✅ 工具在 GitHub Pages 正常訪問和使用
- ✅ 文檔完整清晰

## 關鍵技術決策點

### 1. 時間區塊的尺寸計算

**決策**: 區塊高度 = 任務時長（小時）× 基礎單位（如 30px）

**推理**:
- 直觀性：1 小時區塊始終保持一致的高度
- 易於調整：只需修改基礎單位即可全局調整比例
- 視覺清晰：4 小時區塊的高度恰好是 0.5 小時的 8 倍

**實作細節**:
```javascript
const BASE_UNIT = 30; // pixels per hour
const blockHeight = duration * BASE_UNIT;
```

### 2. 拖曳的狀態管理

**決策**: 在 JavaScript 物件中維護 `position` 屬性（"pool" 或 "container"），同步到 localStorage

**推理**:
- 簡化同步邏輯，DOM 狀態與資料狀態一致
- 頁面重新加載時可精確恢復區塊位置
- 便於擴充（未來支援多個容器）

### 3. localStorage 的序列化方案

**決策**: 使用 JSON.stringify/parse，以易讀的結構存儲

```javascript
// 存儲結構
{
  "tasks": [
    { "id": "uuid", "name": "寫報告", "duration": 2, "position": "container", "createdAt": "2025-12-27T..." }
  ],
  "version": 1
}
```

**推理**:
- JSON 易於調試和版本控制
- 支援未來的資料遷移（透過 version 欄位）
- 人類可讀，便於測試

### 4. 今日容器的容量設定

**決策**: 固定高度 480px（代表 16 小時，基礎單位 30px）

**推理**:
- 16 小時是一般人的有效工作時間
- 480px 在標準桌面螢幕上易於顯示和拖曳
- 參考線標示 8hr、16hr、24hr，讓使用者有多個參考點
- 允許溢出視覺化「超載」，符合設計原則

## 實作順序與依賴關係

```
┌─────────────────────────────────────────────────────────────┐
│ Phase 1: 靜態頁面 (H1.1, H1.2, H1.3)                        │
│ └─ 並行工作（無依賴）                                        │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ Phase 2: 資料層 (D2.1, D2.2, D2.3)                          │
│ └─ 依賴 Phase 1 的 HTML 結構                                 │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ Phase 3: 任務建立 (I3.1, I3.2, I3.3)                        │
│ └─ 依賴 Phase 2 的 Store                                     │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ Phase 4: 拖曳互動 (I4.1, I4.2, I4.3, I4.4)                  │
│ └─ 依賴 Phase 3 的任務建立                                   │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ Phase 5: 邊界與優化 (E5.1-E5.4)                             │
│ └─ 依賴 Phase 4 的核心功能完成                               │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ Phase 6: 部署與文檔 (P6.1-P6.3)                             │
│ └─ 依賴 Phase 5 的完整功能                                   │
└─────────────────────────────────────────────────────────────┘
```

## 工作時間估算

| 階段 | 任務 | 估計工時 | 依賴 |
|------|------|---------|------|
| Phase 1 | 靜態頁面 + CSS | 2-3 天 | 無 |
| Phase 2 | 資料模型 + Store | 2-3 天 | Phase 1 |
| Phase 3 | 任務建立 | 2 天 | Phase 2 |
| Phase 4 | 拖曳互動 | 3-4 天 | Phase 3 |
| Phase 5 | 邊界處理 + 優化 | 2-3 天 | Phase 4 |
| Phase 6 | 部署 + 文檔 | 1-2 天 | Phase 5 |
| **總計** | | **12-18 天** | |

## 技術風險與應對策略

| 風險 | 影響 | 應對策略 |
|------|------|---------|
| localStorage 相容性 | 資料無法持久化 | 提前測試所有目標瀏覽器，準備 IndexedDB 降級方案 |
| 拖曳效能問題 | 使用體驗卡頓 | Phase 4 中優先實現高效拖曳，使用 transform 動畫而非 layout 變更 |
| CSS 相容性 | 樣式破版 | 使用通用 CSS 語法，避免新特性；提前測試 |
| localStorage 容量限制 | 無法儲存超過 100 個任務 | 友善提示使用者清理舊任務；文檔說明限制 |

## 成功定義

- ✅ MVP 的所有功能需求實現（見 SPEC.md 的 FR-001 至 FR-018）
- ✅ 使用者無需說明書即可使用（直覺設計）
- ✅ 資料在瀏覽器重新加載後完整保留
- ✅ 在 Chrome、Firefox、Safari、Edge 上正常運作
- ✅ 拖曳操作流暢（< 100ms 反應時間）
- ✅ 可在 GitHub Pages 上部署和訪問

---

**後續步驟**:
1. 執行 `/speckit.tasks` 命令生成詳細的任務清單 (tasks.md)
2. 開始 Phase 1 開發（靜態頁面）
3. 定期評估進度，根據實際情況調整時程
